(ns testgen.core
  (:use clojure.java.io
        clojure.pprint))

(defn maybe-quote [val]
	"Convert val into a form in which, after being passed through the pretty
	printer, it will be reconstituted in a form useful to the test"
	(cond  
		(symbol? val) (list 'symbol (str val))
		true (list 'quote val)))

(defn write-test [fnname arg]
	(try
		(let [val (eval (list fnname arg))]
		   	(list 'is (list '= (list fnname arg) (maybe-quote val))))
			  (catch Exception e (list 'is (list 'thrown? (.getClass e) (list fnname arg))))))

(defn constant? [arg]
	(not (or
		(symbol? arg)
		(seq? arg)
		(vector? arg)
		(map? arg))))

(def generic-args '(nil () (quote (a :b "c")) true "test" :test 0 Integer/MAX_VALUE 22/7 0.0001 -0.0001))

(defn constants [form]
	"return a list of all elements in this form which are constants"
  (filter constant? (flatten form)))

(defn find-interesting-args [sexpr extra-vars]
	"Find things in sexpr which would be even more interesting if passed as arguments to it"
	(concat generic-args extra-vars
		(flatten
			(map
				#(cond
					(integer? %) (list % (inc %) (dec %))
					(number? %) (list % (+ % 0.0001) (- % 0.0001))
					true %)
				(constants sexpr)))))

(defn testgen [fndef extra-vars]
	(cond (or (= (first fndef) 'def)(= (first fndef) 'defn))
		(let [name (first (rest fndef))]
			 (list 'deftest (symbol (str "test-" name))
				(concat (list 'testing (str name))
					(map #(write-test name %) 
						(find-interesting-args fndef extra-vars)))))))

;; generating a test file

(defn clean-filename [filename]
  "remove the leading 'src/' and trailing '.clj' (if present) from a Clojure file name"
  (let [without-suffix (cond
   		(.endsWith filename ".clj") (.substring filename 0 (- (count filename) 4))
   		true filename)
	prefix-position (.indexOf filename "src/")]
	(cond (> prefix-position -1) (.substring without-suffix (+ prefix-position 4))
		true without-suffix)))

(defn test-filename [filename]
	"return an approximately-correct filename in which to save tests"
	(let [prefix-position (.indexOf filename "src/")
				prefix (cond (> prefix-position -1) (.substring filename 0 prefix-position)
									true "")]
		(str prefix "test/" (clean-filename filename) "_test.clj")))


(defn packagename-from-filename [filename]
  "Return, as a symbol, the package name associated with this filename. There's
  probably a better way of doing this."
  (let [fn (clean-filename filename)]
    (symbol (.replace fn "/" "."))))

(defn find-vars-in-reader [eddie]
	(try
		(let [sexpr (read eddie)]
			(cond
				(nil? sexpr) nil
				(= (first sexpr) 'def) (cons (first (rest sexpr)) (find-vars-in-reader eddie))
				true (find-vars-in-reader eddie)))
		(catch RuntimeException eof)))

(defn find-vars-in-file [filename]
	(with-open [eddie (java.io.PushbackReader. (reader filename))]
		(find-vars-in-reader eddie)))

(defn generate-tests [filename]
  "Generate a suite of characterisation tests for the file indicated by this filename.

  filename: the file path name of a file containing Clojure code to be tested."
  (try
    (let [fn (clean-filename filename)
          pn (packagename-from-filename filename)
					extra-vars (find-vars-in-file filename)]
			(println "Read vars: " extra-vars)
			(println "Writing to: " (test-filename filename))
      ;; load the file so that any functions in it are usable
      (load fn)
      (refer pn)
			(with-open [eddie (java.io.PushbackReader. (reader filename))
                  dickens (writer (test-filename filename))]
	 			(.write dickens (str "(ns " pn "_test\n"))
				(.write dickens (str "\t(:require [clojure.test :refer :all]\n\t["
						pn " :refer :all]))\n\n"))
				(.write dickens 
						";; auto-generated by testgen - see https://github.com/simon-brooke/testgen\n\n") 
				(while (.ready eddie)
					(println "reading...")
					(let [form (read eddie)]
						(cond (= (first form) 'defn)
							(do 
								(println (first (rest form)) "...")
								(pprint (testgen form extra-vars) dickens)))))))
    (catch Exception eof)))

